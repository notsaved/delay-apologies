<!-- index.html for GitHub Pages — minimalist unicode-only status board
     Data file: /tasks.json (place in the same repo). Example below.
     Save as index.html and add a tasks.json at repo root. No build steps needed.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Writing projects status</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;background:#fff;color:#000}
  main{max-width:900px;margin:28px auto;padding:18px}
  h1{font-size:18px;margin:0 0 14px}
  p.desc{margin:0 0 18px;color:#444}
  .card{border:1px solid #eee;padding:12px;margin:10px 0;border-radius:8px}
  .title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .title strong{flex:1}
  .title .pct{font-size:12px;color:#666}
  .small{font-size:12px;color:#666}
  footer{margin-top:18px;font-size:12px;color:#666}
  @media (max-width:520px){main{padding:12px;margin:14px} h1{font-size:16px}}
</style>
</head>
<body>
<main>
  <h1>Apologies for the Delay</h1>
  <p class="desc">If you are waiting for something from me, this is what I'm currently working on, and how it is going:</p>

  <div id="board"></div>

  <footer>Again, apologies for the delay.</footer>
</main>


<script>
(function(){
  // Configuration
  const PROGRESS_BLOCKS = 30;

  // Helper: parse dd/mm/yyyy
  function parseDateDMY(s){
    if(!s) return null;
    const parts = s.split('/').map(x => parseInt(x,10));
    if(parts.length !== 3 || parts.some(isNaN)) return null;
    const [dd, mm, yyyy] = parts;
    return new Date(yyyy, mm - 1, dd);
  }

  // day difference rounded to nearest integer, b - a
  function dayDiff(a, b){
    if(!a || !b) return null;
    const ms = 1000 * 60 * 60 * 24;
    // use UTC dates at midnight to avoid partial-day artifacts
    const utcA = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    const utcB = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
    return Math.round((utcB - utcA) / ms);
  }

  // Build unicode progress bar with filled █ and empty ░
  function buildProgressBar(percent){
    const filled = Math.round((percent/100) * PROGRESS_BLOCKS);
    const empty = PROGRESS_BLOCKS - filled;
    return '█'.repeat(filled) + '░'.repeat(empty);
  }

  // Format date as dd/mm/yyyy
  function formatDMY(d){
    if(!d) return 'n/a';
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth() + 1).padStart(2,'0');
    const yyyy = d.getFullYear();
    return dd + '/' + mm + '/' + yyyy;
  }

  // Lateness text
  function latenessText(daysLate){
    if(daysLate === null) return 'no deadline';
    if(daysLate > 0) return `${daysLate}d late`;
    if(daysLate === 0) return 'due today';
    return `due in ${-daysLate}d`;
  }

  // Calculate expected submission date based on completion percentage per day after deadline
  function calculateExpectedSubmission(origDeadline, currentCompletion){
    if(!origDeadline) return null;
    
    const today = new Date();
    const daysLate = dayDiff(origDeadline, today);
    
    // If not yet late, return null (can't calculate from future)
    if(daysLate === null || daysLate < 0) return null;
    
    // If already complete, return today
    if(currentCompletion >= 100) return today;
    
    // If no progress yet (0%), estimate conservatively - cannot calculate
    if(currentCompletion <= 0) return null;
    
    // Calculate daily progress rate: completion / days elapsed since deadline
    const daysElapsed = daysLate + 1; // include the deadline day itself
    const dailyProgressRate = currentCompletion / daysElapsed;
    
    // Calculate remaining completion and days needed
    const remainingCompletion = 100 - currentCompletion;
    const daysNeeded = Math.ceil(remainingCompletion / dailyProgressRate);
    
    // Calculate expected submission date
    const expectedDate = new Date(today);
    expectedDate.setDate(expectedDate.getDate() + daysNeeded);
    
    return expectedDate;
  }

  // Build a month timeline showing deadline and expected completion
  function buildMonthTimeline(deadlineDate, expectedDate){
    if(!deadlineDate) return 'n/a';
    
    const timelineLength = 40; // longer bar for better precision
    const startMonth = new Date(deadlineDate.getFullYear(), deadlineDate.getMonth(), 1);
    const endDate = expectedDate || deadlineDate;
    const endMonth = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
    
    // Calculate total days to display
    let totalDays = 0;
    let currentDate = new Date(startMonth);
    while(currentDate <= endMonth){
      totalDays++;
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    // Scale to timelineLength
    const daysPerBlock = Math.ceil(totalDays / timelineLength);
    let timeline = '';
    let lastMonthIndex = -1;
    
    currentDate = new Date(startMonth);
    for(let block = 0; block < timelineLength; block++){
      let char = '·';
      let hasDeadline = false;
      let hasExpected = false;
      let monthChanged = false;
      
      // Check all days in this block for markers
      for(let d = 0; d < daysPerBlock && currentDate <= endMonth; d++){
        const checkDate = new Date(currentDate);
        
        // Check for month break
        if(lastMonthIndex !== -1 && checkDate.getMonth() !== lastMonthIndex){
          monthChanged = true;
        }
        
        // Check for deadline and expected date
        if(deadlineDate.toDateString() === checkDate.toDateString()){
          hasDeadline = true;
        }
        if(expectedDate && expectedDate.toDateString() === checkDate.toDateString()){
          hasExpected = true;
        }
        
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      // Prioritize markers: deadline > expected > month break > dot
      if(hasDeadline){
        char = '●';
      } else if(hasExpected){
        char = '○';
      } else if(monthChanged){
        char = '|';
      }
      
      timeline += char;
      if(lastMonthIndex !== currentDate.getMonth() - 1){
        lastMonthIndex = new Date(currentDate.getTime() - 86400000).getMonth();
      }
    }
    
    return timeline;
  }

  // Fetch tasks.json and render
  async function loadAndRender(){
    let tasks = null;
    try{
      const r = await fetch('tasks.json', { cache: 'no-store' });
      if(!r.ok) throw new Error('fetch failed');
      const contentType = r.headers.get('Content-Type') || '';
      if (!contentType.toLowerCase().includes('application/json')) {
        throw new Error('Invalid content-type: expected application/json');
      }
      tasks = await r.json();
    } catch(e){
      // fallback: show message with instructions
      const board = document.getElementById('board');
      board.innerHTML = '<div class="card">Could not load <code>tasks.json</code>. Add it to the repo root with dd/mm/yyyy dates. See example above.</div>';
      return;
    }

    renderTasks(tasks);
  }

  function renderTasks(tasks){
    const board = document.getElementById('board');
    board.innerHTML = '';

    if(!Array.isArray(tasks) || tasks.length === 0){
      board.innerHTML = '<div class="card">No tasks found in tasks.json</div>';
      return;
    }

    tasks.forEach(task => {
      const name = task.name || 'untitled';
      const orig = task.original_deadline ? parseDateDMY(task.original_deadline) : null;
      const comp = Math.max(0, Math.min(100, Number(task.completion) || 0));

      // Calculate expected submission date based on completion percentage per day
      const expect = calculateExpectedSubmission(orig, comp);
      const daysLate = orig ? dayDiff(orig, new Date()) : null;
      const origText = orig ? formatDMY(orig) : 'n/a';
      const expectText = expect ? formatDMY(expect) : 'n/a';
      const bar = buildProgressBar(comp);
      const lateTxt = latenessText(daysLate);

      const card = document.createElement('div');
      card.className = 'card';

      const title = document.createElement('div');
      title.className = 'title';
      const strong = document.createElement('strong');
      strong.textContent = name;
      const pct = document.createElement('span');
      pct.className = 'pct';
      pct.textContent = `${comp}%`;
      title.appendChild(strong);
      title.appendChild(pct);

      const dates = document.createElement('div');
      dates.className = 'small';
      dates.textContent = `deadline: ${origText}  |  expected: ${expectText}`;

      const barLine = document.createElement('div');
      barLine.style.marginTop = '8px';
      barLine.style.fontFamily = 'monospace';
      barLine.textContent = bar;

      const monthLine = document.createElement('div');
      monthLine.style.marginTop = '6px';
      monthLine.style.fontFamily = 'monospace';
      monthLine.style.fontSize = '11px';
      monthLine.className = 'small';
      monthLine.textContent = buildMonthTimeline(orig, expect);

      const lateLine = document.createElement('div');
      lateLine.style.marginTop = '8px';
      lateLine.className = 'small';
      lateLine.textContent = lateTxt;

      card.appendChild(title);
      card.appendChild(dates);
      card.appendChild(barLine);
      card.appendChild(monthLine);
      card.appendChild(lateLine);
      board.appendChild(card);
    });
  }

  // initial load
  loadAndRender();

})();
</script>
</body>
</html>
